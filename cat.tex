\documentclass[12pt]{jarticle}

\usepackage{url}
\usepackage[dvipdfm]{graphicx}

\title{Dart Code Lab}
\author{Kyoto GDG}
\date{2012/09/29}
\begin{document}
\begin{titlepage}
\maketitle
\thispagestyle{empty}
\end{titlepage}
\tableofcontents
\newpage

\section{Introduction}

This codelab will help you build and run a simple chat application using Dart. Along the way, you will learn:

\begin{itemize}
\item The fundamentals of the Dart programming language
\item How to use the Dart HTML libraries
\item Bi-directional communication with WebSockets
\item The basics of Dart Editor
\item How to find answers from the online resources
\end{itemize}

\subsection{Prerequisites}

This codelab assumes you are familiar with fundamental web programming. You should know the basics of HTML, CSS, and JavaScript. You should also have experience with a programming language such as Java, C\#, or JavaScript.

This codelab assumes you have watched the following video tutorials:

\begin{itemize}
\item Google I/O 101: Introduction to Dart with Seth Ladd
\item Google I/O 101: Dart Editor with Devon Carew
\end{itemize}

\subsection{Installs}

This codelab requires the Dart Editor. You can find builds of the editor for Mac, Windows, and Linux at \url{http://dartlang.org/editor/}.

\subsection{Additional materials}

This codelab provides easy to follow, step-by-step instructions. However, you°«ll find it quite useful to have the following online resources loaded up and ready to access.

\begin{itemize}
\item \url{http://api.dartlang.org} The Dart API docs list the functions, classes, and methods for all the libraries.
\item \url{http://www.dartlang.org/docs/language-tour/} The Dart Language Tour is your high-level guide through the Dart language.
\item \url{http://www.dartlang.org/docs/library-tour/} The Dart Library Tour covers most of the bundled libraries of the Dart platform.
\item \url{http://synonym.dartlang.org/} Know JavaScript? This is your resource! Translate common idioms, patterns, and snippets from JavaScript to Dart.
\end{itemize}
\section{•π•∆•√•◊1: ¥ƒ∂≠§Œ•ª•√•»•¢•√•◊}

Dart§«§œ•—•Ô•’•Î§«¿∏ª∫≈™§ •ƒ°º•Î§¨ƒÛ∂°§µ§Ï§∆§§§ﬁ§π°•§Ω§Œ√Ê§«√Êø¥≈™§ ∞Ã√÷§Ú§∑§·§Î§‚§Œ§¨Dart Editor§«§π°•Dart Editor§œ∑⁄ŒÃ§ •∆•≠•π•»•®•«•£•ø§«Dart§Œ•¢•◊•Í•±°º•∑•Á•Û§Œº¬π‘°§•«•–•√•∞°§≤Ú¿œ§¨π‘§®§ﬁ§π°••®•«•£•ø§œDart SDK§‰Dartium\footnote{Dart VM§Ú≈Î∫‹§∑§øChromium}§»∂®ƒ¥§∑§∆∆∞∫Ó§Ú§∑°§≈˝∞Ï§µ§Ï§ø¬Œ∏≥§ÚƒÛ∂°§∑§ﬁ§π°•

\subsection{Ã‹…∏}

\begin{enumerate}
\item Dart Editor§Ú•§•Û•π•»°º•Î
\item Editor•¡°º•‡§À•’•£°º•…•–•√•Ø§Ú¡˜øÆ
\item ª˛∑◊§ŒDart•¢•◊•Í•±°º•∑•Á•Û§Úº¬π‘
\item Dartium§À§ƒ§§§∆≥ÿ§÷
\end{enumerate}

\subsection{•¶•©°º•Ø•π•Î°º}

\subsubsection{Dart Editor§Ú•§•Û•π•»°º•Î}

•ø•π•Ø: GoogleIO§Œª˛§»«€…€ ˝º∞§¨∞€§ §Î§Œ§«°§µ≠Ω“§Ú —ππ

To get your environment set up, plug in the provided USB. Open the USB drive and find the \url{editor/} directory inside. Copy over the correct Dart Editor version for your OS/bit combination directory to your machine, and unzip it.

[Image]

Open up the newly unzipped \url{dart/} directory, and double click the executable:

\begin{itemize}
\item DartEditor.app (Mac)
\item DartEditor (Linux)
\item DartEditor.exe (Windows)
\end{itemize}

[Image]

Dart Editor§ÚΩÈ§·§∆µØ∆∞§π§Î§»°§§Ë§¶§≥§Ω≤ËÃÃ§¨…Ωº®§µ§Ï§ﬁ§π°•

\includegraphics{step1/welcome.png}

\subsubsection{Use the Send Feedback button}

The Dart Editor team really appreciates feedback. The easiest way to let them know your thoughts is to use the Send Feedback button in the upper right of the editor°«s toolbar.

Locate the Send Feedback button and click on it.

[Image]

The Dart Editor Feedback dialog allows you to share bugs and requests directly with the editor team, as well as the larger Dart team. Feel free to send us any and all comments, especially during this codelab. We°«ll turn your suggestions into bug reports and feature requests3 as appropriate.

[Image]

\subsubsection{Run the Clock sample}

(If the feedback window is still open, close it now.)

Time to run a Dart app!

Click on the Clock sample from the Welcome window, which copies the Clock sample into Dart Editor and sets up a new project for you.

[Image]

Tip: Can°«t find the Welcome view? You can go to Tools, Welcome Page to display it again.

[Image]

The Files view shows all of the files in the Clock sample, including all Dart files, the HTML file that hosts the app, as well as all of the images and CSS files. clock.dart is a Dart file that defines the "clock" library, and includes the main() method for the sample. The clock.dart file is automatically opened in the editor.

[Image]

Ensure the clock.dart file is selected and highlighted. Click the Run button in Dart Editor, which launches the application by loading Dartium and pointing it to the clock.html file.

[Image]

Here is the Clock sample app running inside Dartium. Congratulations, you are running your first Dart app!

[Image]

\subsubsection{Dartium}

Dartium is Chromium with an embedded Dart virtual machine (VM). Even though Dart compiles to JavaScript, you can speed up the "edit, reload" development cycle by running Dart apps directly in the browser.

To verify that Clock is running in Dartium, right-click in the browser and select Inspect Element.

[Image]

The Elements tab should be selected by default, and clock.dart should be listed as the script that is being run.

[Image]

\subsubsection{Debug with the Dart Editor}

With Dart running directly in Dartium, the editor has debugging support for Dart applications. Set a breakpoint by double clicking in the left hand gutter in Dart Editor on first call to setDigits() inside the updateTime() method in clock.dart, line 66. With the breakpoint set (you will see a little blue dot in the gutter), click the Run button again.

[Image]

Notice how the program stop, and the Debugger view opens in the Dart Editor. To continue the program without leaving the debugger, click the Resume button (the green arrow in the Debugger view). The updateTime() method is called every 1000ms, therefore the breakpoint will be hit again within a second.

[Image]

The Debugger view on the right hand side allows you to see which processes are running and what values are in scope at the breakpoint. Hover over the now field, the value will be displayed in a tooltip.

[Image]

To terminate the debugger, click on the red square in the Debugger view. This will also stop the application.

[Image]

\subsection{Advanced}

Load and launch the other samples.
In the Clock sample, try changing the ball velocity or the gravity. Start with lines 12 and 117 in balls.dart.
Set more breakpoints and inspect the values by opening up the variables.

[Image]
\section{Step 2: Import and run the chat app}

This codelab walks you through a custom chat application. You will now load this chat app into the editor and learn how to run both client and server Dart apps.

\subsection{Objectives}

\begin{enumerate}
\item Load existing code into Dart Editor
\item Run the finished Dart Chat app
\begin{enumerate}
\item Run a command-line app
\item Run a Dartium app
\end{enumerate}
\item View running processes
\item Read and clear console output
\item Close a running process
\end{enumerate}

\subsection{Walkthrough}

\subsubsection{Load Dart Chat into Dart Editor}

If you are using a provided USB drive, copy over the dartchat/ directory from the USB thumb drive to your computer. If you do not have a provided USB drive, you can download the source code.

Load the sample project for this codelab into the editor. Select File > Open Folder... in the editor. Find the dartchat/ directory that you copied from the USB or downloaded, select it, and click Open.

[Image]

You will see a new dartchat project in the editor.

[Image]

\subsubsection{Launch the completed version of the Dart Chat sample}

The sample chat app has both a client and a server component.
Run the server first. In the Files view on the left hand side of Dart Editor, navigate into the dartchat directory, dartchat > finished > chat-server.dart. Right click chat-server.dart and select Run.

[Image]

Verify the server is running by checking the chat-server.dart console output window at the bottom of your editor. You should see a message: "listening for connections on 1337".

[Image]

Next, run the client. Navigate into the client directory, and run the chat-client.dart file in the same way.

[Image]

Notice how Dartium opens the chat app. Verify the chat client is connected to the server by looking for a "[system]: Connected" message in the chat window.

[Image]

Open up another tab to have a proper chat. Right click the ‚ÄúDart Chat‚Äù tab and
select ‚ÄúDuplicate‚Äù.

[Image]

Drag the new tab into its own window. Experiment by sending messages between the two tabs.
For more fun, add more clients.

[Image]

\subsubsection{Debugger view and console output}

Switch back to Dart Editor and select the Tools > Debugger in the top level menu. This lists the two processes that you started, the server and the client.

[Image]

On the bottom of Dart Editor are two views, chat-server.dart and Dartium launch. Each view has the output from the respective process.

[Image]

To clear a console output, click on the gray X icon in upper right of the console output view. To kill the process, click on the red box in the upper right of the console output view. After clicking on the red box, you will notice that the Debugger is updated to show that the process was killed.
Stop both processes now, first for the Dartium launch, and then for the chat-
server.dart.

[Image]

\subsection{Advanced}

If you finish early, explore more of the chat sample app code. Specifically, investigate the chat server code. The server logs to a file via an isolate, you can learn more about isolates in the Dart Library Tour.
\section{Step 3: Navigate the chat app, and learn basic Dart language features}

The Dart language is familiar to a wide range of developers. It is a class-based object oriented language with single inheritance, curly braces, and semicolons. The syntax is instantly recognizable and the concepts are comfortable.

As you tour the chat code, you will learn the basics of the Dart language. You can use Dart Editor‚Äôs code navigation features, such as search, outlines, and jump to definition to come up to speed more quickly with unfamiliar code.

\subsection{Objectives}

\begin{enumerate}
\item Search for code using Dart Editor
\item Jump to definition of class or method
\item Use the Outline view to see file structure
\item Learn about classes, superclass, generics, functions, methods, variables, libraries, and more
\item Learn about optional static types
\item Understand basic layout of sample app
\item Understand warnings in Dart Editor
\item Understand errors in Dart Editor
\end{enumerate}

\subsection{Before You Begin - Code}

Begin your coding journey in the start-here directory of dartchat. If you need to catch up, or if you need to start over, you can copy step03 into start-here for this portion of the codelab.

\subsection{Walkthrough}

In order to demonstrate Dart language and editor features, you will create a class to represent the chat window on the HTML page. This process will teach you more about the Dart Editor and the Dart language.

\subsubsection{Project layout}

Before you begin coding, it's helpful to understand the layout of the project. Open the finished directory, inside of the dartchat project in Dart Editor. Now, open the client directory to get a full layout of the finished app.

[Image]

You will spend your time inside the client directory, mostly working on chat-client.dart. The project includes the code for both the client (chat-client.dart) and the server (chat-server.dart).

\subsubsection{Search for code}

Use the Search feature of the editor, in the upper right of the tool, to find "Very first edit" (a helpful comment that the authors included for you :), so you can start editing.

[Image]

The search results are displayed in a dedicated view at the bottom of the editor.

[Image]

Double-click on the chat-client.dart from start-here to open the file and start writing some Dart!

Tip: Use start-here to make all of your edits. Be sure not to edit step03, as this is intended to give you a fallback if you need to restart your tasks.

\subsubsection{Add a top-level variable}

Ensure client/chat-client.dart is open and scrolled to the top. Add a top-level variable for an object to represent the the chat window. Use chatWindow as the variable name and ChatWindow as the type annotation.

\begin{verbatim}
// client/chat-client.dart
...
UsernameInput usernameInput;
// Step 3: Very first edit
// Step 3: Add variable for chat window.
ChatWindow chatWindow;
class ChatConnection {
...
\end{verbatim}

Tip: You can use top-level functions and variables instead of wrapping everything in a class.

Save the file. Notice that after you add the new variable with a type annotation, the editor gives you a warning (with a yellow underline) indicating that it doesn‚Äôt know what ChatWindow is. That makes sense, as we haven‚Äôt defined it yet.

[Image]

Advanced Topic: Dart is an optionally typed language, which means you can use type annotations when you want them, and leave them off when you don‚Äôt. If the runtime can‚Äôt find the type you are referring to, it will ignore that static type annotation and treat the variable as Dynamic (the stand-in type when no other type annotation is provided). A missing type mentioned in a type annotation does not prevent the program from compiling and running (because, again, Dart is optionally typed). It is only a warning that the editor can‚Äôt find ChatWindow.

\subsubsection{Instantiate an object}

Scroll down to main() to create a new instance of ChatWindow. Much like other languages, use the new keyword to construct a new object.

\begin{verbatim}
// client/chat-client.dart
main() {
// Step 4: Identify elements by ID.
TextAreaElement chatElem = null;
InputElement usernameElem = null;
InputElement messageElem = null;
// Step 3: Instantiate ChatWindow.
chatWindow = new ChatWindow(chatElem);
usernameInput = new UsernameInput(usernameElem);
...
\end{verbatim}

Notice how the editor is reporting an error now, with a red underline. Specifically, the error is ``no such type: ``ChatWindow''''.

[Image]

An error will stop a program from compiling and running, so this is a problem that must be fixed before continuing. Dart strives to minimize the number of situations that result in a true error, but Dart does need to know what kind of object you want to construct.

\subsubsection{Define a class}

To silence the error, add the ChatWindow class. Find the ‚ÄúDefine the ChatWindow class‚Äù comment and add the following class:

\begin{verbatim}
// client/chat-client.dart
...
// Step 3: Define the ChatWindow class.
class ChatWindow extends View<TextAreaElement> {
}
...
\end{verbatim}

The editor will give you an error about a missing constructor. Don't worry, we'll fill this in next. The ChatWindow class extends the View class (already defined for you in the application). The View class uses generics to further specify the type of the HTML element the view encapsulates. The above code says ‚ÄúChatWindow is a specialized View of a TextAreaElement‚Äù.

Advanced Topic: Dart support parameterized types, also known as generics. As with Dart‚Äôs optional types, you don‚Äôt need use generics. However, they are a powerful tool to help add more expressiveness to your code. Dart‚Äôs generics8 are probably simpler than those found in other mainstream languages.

Add a constructor to ChatWindow that delegates to the constructor from View:

\begin{verbatim}
// client/chat-client.dart
...
// Step 3: Define the ChatWindow class.
class ChatWindow extends View<TextAreaElement> {
ChatWindow(TextAreaElement elem) : super(elem);
...
\end{verbatim}

What follows the : is the initializer list9 for a class, used to initialize final variables and the super constructor. Next, add two public methods and one private method to ChatWindow. These methods will display messages to the <textarea> element.

\begin{verbatim}
// client/chat-client.dart
...
class ChatWindow extends View<TextAreaElement> {
ChatWindow(TextAreaElement elem) : super(elem);
displayMessage(String msg, String from) {
_display("$from: $msg\n");
}
displayNotice(String notice) {
_display("[system]: $notice\n");
}
_display(String str) {
elem.text = "${elem.text}$str";
}
}
...
\end{verbatim}

n the above code, the \_display() method is library private. Names that are prefixed with an underscore are private to the library they are defined within. The ChatWindow class is defined in a file that is marked as \#library('chat-client'), therefore \_display() is only visible to code also in the 'chat-client' library. The other two methods are public.
The text property of elem accessing the contents of the <textarea> tag.
One of Dart‚Äôs handy features is string interpolation, used in all three methods above. You can compose strings like "\$from: \$msg\\n" by directly referencing variables with a \$ prefix. Note that elem, used inside of \_display(), is found in the View superclass. ChatWindow extends View, thus gaining access to View's instance variables.

\subsubsection{View the code outline}

With the ChatWindow class now added, you can use the editor to easily browse the outline of the chat-client.dart file.
Select the chat-client.dart file and select the menu, Tools, Outline.

[Image]

The Outline view will now appear, with a tree view of the classes, methods, and variables found in chat-client.dart.

[Image]

\subsection{Advanced}

Learn more about the Dart language, such as strings and classes. Right-click a class name and select Open Declaration. Try this with classes defined in chat-client.dart as well as classes from Dart.

[Image]

Right-click a method and select Open Callers. You‚Äôll see a list of all the locations that call this method.

[Image]
\section{Step 4: Respond to changes in input fields}

Web developers are familiar with the DOM (Document Object Model, a set of APIs to access browser features), but most use jQuery to smooth over the browser interfaces and inconsistencies. Similar to how jQuery makes the DOM feel like JavaScript, Dart offers an HTML library to make programming the browser feel like Dart.

The HTML library12 provides access to the elements on the web page‚Äî<div>, <p>, and so on. You can find elements on the page, create new elements, change text, and lots more. You can also access new HTML5 features such as IndexedDB, Application Cache, and WebGL with the HTML library.

Web applications run in a single UI thread on the page13. To minimize visible pauses or delays, responses to events like mouse clicks and button presses happen inside of callbacks. Once you have a handle to an element on the page, such as an input field, you can register a function to be run on certain events (for example the ‚Äúon change‚Äù event).

\subsection{Objectives}

\begin{enumerate}
\item Import a library
\item Find elements on an HTML page with CSS selector
\item Bind to events from HTML elements
\item Use lexical closures, inline callbacks, and one-line functions
\item Enable and disable input fields
\item Get the contents of an input element
\item See a Dart getter in action
\item Use code completion in Dart Editor to discover which methods you can use
\end{enumerate}

\subsection{Code}

If you need to catch up, you can copy step04 onto start-here for this portion of the codelab.

\subsection{Walkthrough}

Before you start on the code, we will introduce you to one of the more productive and helpful features of Dart Editor: code completion.
With enough type information (from direct type annotations, simple inferencing, or type propagation), Dart Editor can provide a list of available methods or fields on an object. On a Mac, Control-Space triggers code completion.

[Image]

As you are writing the code for this and future steps, try code completion. If Dart Editor doesn‚Äôt give you reasonable options, try adding a type annotation to the object that you are working with.

(Tip: If you are trying code completion, and it's not giving you the right suggestions, use the Send Feedback button to let the Dart team know. Please include the code snippet that you are trying.)

\subsubsection{Identify the elements in HTML}

You will now add the HTML library, find existing elements on the page, register for events, and manipulate DOM elements.

Open client/index.html. Identify the IDs for the two <input> elements and the <textarea> element. For example:

\begin{verbatim}
// client/index.html
<textarea id="chat-display" rows="10" cols="100" disabled></textarea>
...
<input id="chat-username" name="chat-username" type="text">
...
<input id="chat-message" name="chat-message" type="text" disabled
value="enter username...">
\end{verbatim}

HTML element IDs are unique in a document, making it easy to find a specific element.

\subsubsection{Verify the dart:html library is imported}

With the three IDs identified, you can use Dart‚Äôs HTML library to get a handle on those elements. Open client/chat-client.dart and scroll to the top of the file.

Notice the dart:html import is already added for you. We left this in to eliminate errors, but normally you would add this import yourself.

\begin{verbatim}
// client/chat-client.dart
#library('chat-client');
#import('dart:html');
...
// This is already here, just pointing it out. :)
...
\end{verbatim}

\subsubsection{Find HTML elements}

Use the query(String selector)14 top-level function from dart:html to find elements in an HTML page. The query() function takes a CSS selector and returns a single matching element. (A corresponding queryAll()15 function returns all matching elements.)

CSS selectors16 are powerful pointers to elements on an HTML page. You can use them to find elements by IDs, class names, attribute values, position in the DOM, and more. For this step, you will use the element‚Äôs ID as the selector. For example, the CSS selector \#the-id will search for an HTML element with an ID of the-id.

Get the three element IDs that you identified from client/index.html ready. Next, scroll down to the bottom of client/chat-client.dart and find the main() method. Use what you know about IDs, CSS selectors, and the query() function to associate each HTML element with its equivalent Dart object from your app.

\begin{verbatim}
/ client/chat-client.dart
...
main() {
// Step 4: Identify elements by ID.
TextAreaElement chatElem = query('#chat-display');
InputElement usernameElem = query('#chat-username');
InputElement messageElem = query('#chat-message');
chatWindow = new ChatWindow(chatElem);
usernameInput = new UsernameInput(usernameElem);
messageInput = new MessageInput(messageElem);
...
\end{verbatim}

Advanced Topic: The astute reader might notice that the query() methods return
an Element17, yet the returned variable is annotated with more specific types
(TextAreaElement18 and InputElement19). Dart allows an ‚Äúdowncast‚Äù because it is
by nature an optionally typed language, and it promotes an ‚Äúinnocent until proven guilty‚Äù programming experience. As long as the type annotation is in the type hierarchy of the expected return type, Dart‚Äôs tools do not create a warning.

Notice how the constructors for ChatWindow, UsernameInput, and MessageInput all take a DOM element. Here‚Äôs an example:

\begin{verbatim}
// client/chat-client.dart
...
class MessageInput extends View<InputElement> {
MessageInput(InputElement elem) : super(elem);
...
\end{verbatim}

\subsubsection{Bind to events using lexical closures}

You will now learn how to bind a function to an HTML element event. Specifically, you will bind event handlers to the ‚Äúon change‚Äù events for both the username input field and the message input field.
For a simple one-line callback function, use the one-line style:

\begin{verbatim}
element.on.event.add((event) => handleTheEvent())
\end{verbatim}

The event can be a mouse click, a button press, a value change, or any number of interesting actions or state changes.

Tip: Pull up the API docs for ElementEvents20 to see all the possible events from an Element.

The one-line function syntax ( => ) used above is shorthand sugar for

\begin{verbatim}
element.on.event.add((event) {
return handleTheEvent();
});
\end{verbatim}

There‚Äôs nothing special about the => being used for callbacks, you can use it anywhere a one-line function is valid. For example, here‚Äôs a simple class with a simple one-line function:

\begin{verbatim}
// for illustrative purposes only, not part of the codelab
class Person {
String firstName, lastName;
Person(this.firstName, this.lastName);
String toString() => '$firstName $lastName';
}
\end{verbatim}

Dart‚Äôs lexical closures make writing nested functions and callbacks easy. You can access variables in lexical scope from within callback functions, and even the "this" object is defined by its lexical scope.

Advanced Topic: Lexical scope defines scope through the program structure. You
can ‚Äúfollow the curly braces‚Äù to see which objects or variables are in scope, and that scope does not change based on program behavior. The following code snippet displays a few examples of lexical scope:

[Image]

Notice how the onNoMoreCarrots callback handler can access numCarrots,
bunnies, and farmerName.

You will add the code to listen for the username input field‚Äôs change event. When the username field is empty, the message input field should be disabled. When the username input field has a value, the message input field should be enabled.

\subsubsection{Handle username field changes}

Open client/chat-client.dart and find the UsernameInput class. Add the event
handler inside the bind() method of UsernameInput:

\begin{verbatim}
// client/chat-client.dart
class UsernameInput extends View<InputElement> {
UsernameInput(InputElement elem) : super(elem);
bind() {
// Step 4: Handle change event for username input.
elem.on.change.add((e) => _onUsernameChange());
}
...
\end{verbatim}

Next, inside of \_onUsernameChange(), you should enable the message input element if the username input element is not empty.

\begin{verbatim}
// client/chat-client.dart
_onUsernameChange() {
// Step 4: Enable the message input if username input
// is not empty, or disable the message input if username input
// is empty.
if (!elem.value.isEmpty()) {
messageInput.enable();
} else {
messageInput.disable();
}
}
...
\end{verbatim}

Notice that InputElement‚Äôs value field21 is used to get the contents of the input field. The isEmpty()22 is available to strings, and returns true if the string contains zero characters.

The enable() and disable() methods are called on the instance of MessageInput, a class we created for this chat application. Go check out the implementations for these methods.

\subsubsection{Handle message field changes}

The mechanics of handling the message input field are similar. When the message input field changes, you should do three things:

\begin{enumerate}
\item Send the message via the chat connection
\item Display the message in the chat window
\item Erase the message input field
\end{enumerate}

Find the MessageInput class and add the following code:

\begin{verbatim}
// client/chat-client.dart
class MessageInput extends View<InputElement> {
MessageInput(InputElement elem) : super(elem);
bind() {
// Step 4: When the message input changes,
// send the message, display the message, and clear the message input.
elem.on.change.add((e) {
connection.send(usernameInput.username, message);
chatWindow.displayMessage(message, usernameInput.username);
elem.value = '';
});
}
\end{verbatim}

Notice that connection.send() is passed message, which is a getter method inside of MessageInput:

\begin{verbatim}
class MessageInput extends View<InputElement> {
...
String get message() => elem.value;
...
}
\end{verbatim}

Advanced Topic: A getter is a method that looks like a field and does not require () when called. Getters and setters23 are intended for advanced API design, usually to help with refactoring from simple public fields to encapsulated properties.

\subsection{Advanced}

Instead of sending the message when the input field changes, send it when a Send button is clicked. Add a button, label it, and respond to click events.
Add a timestamp to messages displayed in the ChatWindow. Hint: check out the Date24 class from dart:core.

\section{Step 5: Encode and decode data with JSON}

JSON, or JavaScript object notation, is a handy text format for encoding structured data like arrays, numbers, strings, booleans, and maps. JSON is well supported across programming languages and libraries, making it easy to perform data interop across systems.

Here‚Äôs what an arbitrary data object looks like when encoded into a JSON string:

\begin{verbatim}
// A Dart map
var data = {'scores': [12,54,99]};
assert(data is Map);
assert(data['scores'] is List);
assert(data['scores'][0] == 12);
// Convert to JSON string
var json = JSON.stringify(data);
// A Dart map encoded as a JSON string
assert(json == '{"scores": [12, 54, 99]}');
\end{verbatim}

Looks pretty similar to Dart‚Äôs map and list literals!

\subsection{Objectives}

\begin{enumerate}
\item Learn about JSON
\item Encode objects with into a JSON string
\item Decode a JSON string into an object
\end{enumerate}

\subsection{Code}

If you need to catch up, you can copy step05 onto start-here for this portion of the codelab.

\subsection{Walkthrough}

Open client/chat-client.dart and scroll to the top of the file. You will now add the JSON library, encode and decode JSON, and try some new Dart Editor features.

\subsubsection{Import dart:json}

To use the JSON functionality bundled with Dart, import the dart:json into the chat-client library, found in client/chat-client.dart.

\begin{verbatim}
// client/chat-client.dart
#library('chat-client');
#import('dart:html');
// Step 5: Import the JSON library.
#import('dart:json');
ChatConnection chatConnection;
\end{verbatim}

\subsubsection{Encode a message for sending}

Find send() in ChatConnection and add the code to encode, or ‚Äústringify‚Äù, both the username and message into a single JSON string.

\begin{verbatim}
// client/chat-client.dart
send(String from, String message) {
// Step 5. Encode from and message into one JSON string.
var encoded = JSON.stringify({'f': from, 'm': message});
_sendEncodedMessage(encoded);
}
\end{verbatim}

The above code creates a map literal using the { } syntax. Both the from username and the message are placed into a single map, effectively saying ‚Äúthis message was sent by this username‚Äù. The map is then encoded into a JSON string with JSON.stringify().

Once the message is encoded into a string, it is passed to \_sendEncodedMessage() to be sent by the WebSocket (which you‚Äôll code up in the next step).

\subsubsection{Decode a received message}

Use JSON.parse() to decode a JSON string into a Dart object. Find \_receivedEncodedMessage() inside ChatConnection and add the code to decode a message and display it in the chat window.

\begin{verbatim}
// client/chat-client.dart
_receivedEncodedMessage(String encodedMessage) {
// Step 5: Decode a JSON string and display it in the chat window.
Map message = JSON.parse(encodedMessage);
if (message['f'] != null) {
chatWindow.displayMessage(message['m'], message['f']);
}
}
\end{verbatim}

There is a bit of error checking code, ensuring the message has a sender‚Äôs username (f is short for from).

\subsection{Advanced}

Handle an incorrectly formatted message. Display a helpful message if a client receives a message it can't parse or understand.

\section{Step 6: Keep code clean with Dart Editor‚Äôs refactoring tools}

Refactoring is the art of changing the structure of code without changing the behavior of code. It‚Äôs important to clean your code as you evolve the system. Mature coding environments can help automate refactorings, reducing the friction to code maintenance.

A common refactoring technique is renaming methods, variables, classes, etc as more clear names become apparent. Keeping names understandable and clear is important for code health. Dart Editor can perform many automated rename refactorings for you.

\subsection{Objectives}

\begin{enumerate}
\item Automatically rename methods and variables
\end{enumerate}

\subsection{Code}

If you need to catch up, you can copy step06 onto start-here for this portion of the codelab.

\subsection{Walkthrough}

Open client/chat-client.dart and scroll to the top. You will use Dart Editor to
automatically rename variable names.

\subsubsection{Rename a variable}

Find the ChatConnection connection object, near the top. Rename this variable to
something a bit more clear, as connection is vague. A quick glance at connection and we‚Äôre not sure if it‚Äôs the actual WebSocket connection. Of course your tools can tell you, but you want readable code.

Right click on the word connection, and select Rename...

[Image]

The variable name connection is highlighted, and you are instructed to enter a new name. Change the name to chatConnection. Press enter after you change the name.

[Image]

\subsubsection{Review the changes}

The name connection has been changed to chatConnection throughout the file. Scroll to the bottom of the file. You‚Äôll see the name was changed inside main(). The name was also changed inside the bind() method of MessageInput.

You can search for chatConnection using Dart Editor search.

[Image]

\subsection{Advanced}

Rename other methods and variables. Try renaming variables that are statically typed, and variables that are dynamically typed with var.

Tip: You might want to undo any other changes after you play around, because future steps might be a bit confusing if you change too many names.
\section{Step 7: Send and receive data with WebSockets}

WebSockets25 are part of the HTML5 family of technologies. They enable bi-directional full-duplex communication between a modern web browser and a WebSocket server. WebSockets can stream discrete messages, either text or binary data.

WebSockets are more efficient than long polling or constant querying over HTTP. They are ideal for chat applications! :)

\subsection{Objectives}

\begin{enumerate}
\item Learn about WebSockets
\item Connect to a WebSocket server
\item Receive data from a WebSocket
\item Send data to a WebSocket
\end{enumerate}

\subsection{Code}

If you need to catch up, you can copy step07 onto start-here for this portion of the codelab.

\subsection{Walkthrough}

Open client/chat-client.dart and find the ChatConnection class. You will now add a WebSocket connection, listen for messages, and send messages.

Tip: Open the API docs for the WebSocket class at http://api.dartlang.org/html/WebSocket.html.

\subsubsection{Connect to the WebSocket server}

Add a new instance field for the WebSocket to the ChatConnection class.

\begin{verbatim}
// client/chat-client.dart
class ChatConnection {
// Step 7. Add webSocket instance field.
WebSocket webSocket;
String url;
ChatConnection(this.url) {
\end{verbatim}

When the WebSocket instance is instantiated, it attempts to connect to the server at the URL. Find \_init inside of ChatConnection and add the following code.

\begin{verbatim}
// client/chat-client.dart
_init() {
// Step 7. Connect to the WebSocket, listen for events.
chatWindow.displayNotice("Connecting to Web socket");
webSocket = new WebSocket(url);
\end{verbatim}

First, the code displays a message to the chat window indicating that it's attempting a connection to the WebSocket server. Second, it instantiates a new WebSocket object, which attempts to connect to the WebSocket server.

Use the Open Declaration feature of the editor to determine where the url variable comes from.

[Image]

Notice how the url variable is an instance variable of ChatConnection, originally set in the constructor.

\subsubsection{Handle WebSocket events}

WebSocket objects respond to four events: open, close, error, and message. The message event is fired when a new message is received on the WebSocket. The content of the message is found in event.data.

Tip: Open the API docs for the WebSocket events at http://api.dartlang.org/html/
WebSocketEvents.html.

Handle the four WebSocket events inside of ChatConnection's \_init.

\begin{verbatim}
// client/chat-client.dart
_init() {
// Step 7. Connect to the WebSocket, listen for events.
chatWindow.displayNotice("Connecting to Web socket");
webSocket = new WebSocket(url);
webSocket.on.open.add((e) {
chatWindow.displayNotice('Connected');
});
webSocket.on.close.add((e) {
chatWindow.displayNotice('web socket closed');
});
webSocket.on.error.add((e) {
chatWindow.displayNotice("Error connecting to ws");
});
webSocket.on.message.add((e) {
print('received message ${e.data}');
});
}
\end{verbatim}

Now that the event listeners for WebSocket events are configured, you are ready to use the \_receivedEncodedMessage() method you created from Step 5.

\begin{verbatim}
// client/chat-client.dart
webSocket.on.message.add((e) {
print('received message ${e.data}');
_receivedEncodedMessage(e.data);
});
\end{verbatim}

\subsubsection{Send messages to the WebSocket server}

Finally, with the webSocket instance connected, you can send messages to the server. Find \_sendEncodedMessage() in the ChatConnection class and send the encoded message to the WebSocket server. Only send the message if the webSocket object exists and is actually connected to the server.

\begin{verbatim}
// client/chat-client.dart
_sendEncodedMessage(String encodedMessage) {
// Step 7. Send the message over the WebSocket.
if (webSocket != null && webSocket.readyState == WebSocket.OPEN) {
webSocket.send(encodedMessage);
} else {
print('WebSocket not connected, message $encodedMessage not sent');
}
}
\end{verbatim}

\subsubsection{Test the app}

Everything should be wired up, time to test your app!

Run the chat-server.dart, if not already running (see Step 2 for instructions). Next, run the client/chat-client.dart application, which launches Dartium. The chat window will print [system]: Connected if the client connects to the WebSocket server.

[Image]

Check the chat-server.dart output in the Dart Editor to see "new ws conn message", which confirms your client has connected to the WebSocket server.

[Image]

Not connecting to the server? Make sure the chat-server.dart is running. Sometimes, completely shutting down and restarting Dartium helps.
Send some messages! Copy the URL in Dartium, open a new Dartium tab, and paste the URL in. Enter a different username, and start chatting between the two windows.

[Image]

\subsection{Advanced}

Handle connection failures by retrying the connection attempt. Add increasing back-off retry delays.

Update the \_init() method to take a number of seconds to wait before retrying the connection. Add a boolean to track if an error was encountered (you will use this shortly).

\begin{verbatim}
// client/chat-client.dart
_init([int retrySeconds = 2]) {
// Step 6
bool encounteredError = false;
\end{verbatim}

In both the close and error event handlers, add a retry to reconnect after a delay. Set the encounteredError boolean to true so the retry timer is scheduled only once, in the event that both close and error events are fired.

\begin{verbatim}
// client/chat-client.dart
webSocket.on.close.add((e) {
chatWindow.displayNotice('web socket closed, retrying in $retrySeconds
seconds');
if (!encounteredError) {
window.setTimeout(() => _init(retrySeconds*2), 1000*retrySeconds);
}
encounteredError = true;
});
webSocket.on.error.add((e) {
chatWindow.displayNotice("Error connecting to ws");
if (!encounteredError) {
window.setTimeout(() => _init(retrySeconds*2), 1000*retrySeconds);
}
encounteredError = true;
});
\end{verbatim}

The setTimeout() method takes two arguments: a function and when it should be called (in milliseconds from now). In this case, the \_init() method runs after retrySeconds. This is a good example of Dart‚Äôs lexical closures, because the inline function for setTimeout() easily references both \_init() and retrySeconds.

\section{Step 8: Compile to JavaScript, run in other browsers}

One of Dart‚Äôs core features is that it compiles to modern JavaScript to run across the modern web.

\subsection{Objectives}

\begin{enumerate}
\item Compile client app to JavaScript
\item Run Dart app in production browser
\item Understand how the same code runs in Dartium and production browsers
\end{enumerate}

\subsection{Walkthrough}

Open and show the finished directory. This ensures you are compiling a working application. You can do this step in start-here if you are all caught up and it works successfully in Dartium (see previous step).

Select the finished/client/chat-client.dart file.

[Image]

Choose Tools from the top menu and then select Generate JavaScript. This uses the dart2js26 compiler to convert the Dart client app into modern JavaScript.

[Image]

Notice the output in the console view at the bottom of Dart Editor, confirming compilation has succeeded.

[Image]

A finished/client/chat-client.dart.js file is generated.

[Image]

Ensure the chat-server.dart application is running. See a previous step for instructions.

Run the finished/client/chat-client.dart client application. This will start Dartium. See a previous step for instructions.

The application is now running Dartium. Grab the URL and copy it to the clipboard.

[Image]

Open up Chrome (not Dartium!) and paste in the URL to load up the app. Chat between Dartium, running Dart code on the VM, and Chrome, running Dart compiled to JavaScript.

[Image]

\begin{itemize}
\item {\bf Note:} As of 2012-06-26, FireFox wouldn‚Äôt connect. We don‚Äôt think this is a Dart issue, but a WebSocket issue. Suggestions most welcome! If you have Firefox, please test WebSockets at \url{http://www.websocket.org/echo.html} and let us know.
\item {\bf Note:} As of 2012-06-26, Safari does not speak the latest version of the WebSockets protocol. Here‚Äôs the bug to track: \url{http://code.google.com/p/dart/issues/detail?id=3631}
\end{itemize}

How does the same URL work in both Dartium and non-Dartium browsers? Open finished/ client/index.html and notice the two scripts:

\begin{verbatim}
<script type="application/dart" src="chat-client.dart"></script>
<script src="dart.js"></script>
\end{verbatim}

The dart.js file detects whether your browser has a Dart VM. If not, it removes the application/dart script and replaces it with a text/javascript script tag that points to chat-client.dart.js.

\subsection{Advanced}

Rebuild Gmail, but in Dart. Or, open up dart.js to learn more.

If you have time, you can add support for a command that lists all the people in the chat room.

Or, send a list of all people in a chat room when a new person joins the room.

\section{Step 9: Super duper advanced ideas}

Got this far? Congrats! Here are a few ideas to sharpen your Dart point.

\begin{itemize}
\item Add simple formatting when displaying the message. Parse messages, look for words wrapped with asterix‚Äôs, and bold those words when displayed in the chat window. You might find Dart‚Äôs Regular Expressions27 helpful here.
\begin{itemize}
\item For example, if a user types "*Dart is rad!!*" you should display "Dart is rad!!"
\end{itemize}
\item Store the username into the browser‚Äôs Local Storage and load it up when the client appstarts. The Local Storage interface28 will be useful.
\end{itemize}
\section*{º’º≠}

§≥§Œ ∏ΩÒ§ŒÀ›Ãı§À§¢§ø§Í°§À›Ãı§À§¥∂®Œœ§Ú≤º§µ§Í§ﬁ§∑§øº°§Œ ˝§À¥∂º’§§§ø§∑§ﬁ§π°•

\begin{itemize}
\item Introduction XY§µ§Û
\item Step1 XY§µ§Û
\item Step2 YZ§µ§Û
\end{itemize}

§ﬁ§ø°§§≥§Œ§Ë§¶§ §π§–§È§∑§§CodeLab§Œ•∆•≠•π•»µ⁄§”∂µ∫‡§Ú§¥ƒÛ∂°≤º§µ§Í°§§ﬁ§ø°§∆¸À‹∏Ï§ÿ§ŒÀ›Ãı§Ú§¥≤˜¬˙≤º§µ§Í§ﬁ§∑§øGoogle Inc.§Œ...

∫«∏Â§À...

\end{document}
